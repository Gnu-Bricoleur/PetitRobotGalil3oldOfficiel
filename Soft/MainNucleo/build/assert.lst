ARM GAS  /tmp/ccb54Pgm.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 1
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.file	"assert.c"
  17              		.text
  18              	.Ltext0:
  19              		.cfi_sections	.debug_frame
  20              		.global	__aeabi_f2d
  21              		.global	__aeabi_ddiv
  22              		.global	__aeabi_dadd
  23              		.global	__aeabi_dmul
  24              		.section	.text.updatePos,"ax",%progbits
  25              		.align	2
  26              		.global	updatePos
  27              		.thumb
  28              		.thumb_func
  30              	updatePos:
  31              	.LFB123:
  32              		.file 1 "Src/assert.c"
   1:Src/assert.c  **** #include "assert.h"
   2:Src/assert.c  **** 
   3:Src/assert.c  **** #define Kp_Droite 10
   4:Src/assert.c  **** #define Ki_Droite 0
   5:Src/assert.c  **** #define Kd_Droite 0
   6:Src/assert.c  **** 
   7:Src/assert.c  **** 
   8:Src/assert.c  **** #define Kp_Gauche 10
   9:Src/assert.c  **** #define Ki_Gauche 0
  10:Src/assert.c  **** #define Kd_Gauche 0
  11:Src/assert.c  **** 
  12:Src/assert.c  **** #define Kp_Angle 1000
  13:Src/assert.c  **** 
  14:Src/assert.c  **** char consignes[] = {'M','E'};
  15:Src/assert.c  **** double val1[] = { 2000, 0 };
  16:Src/assert.c  **** double val2[] = { 0, 0 };
  17:Src/assert.c  **** 
  18:Src/assert.c  **** int endOfMvt = 0;
  19:Src/assert.c  **** 
  20:Src/assert.c  **** 
  21:Src/assert.c  **** void updatePos(int tickRight, int tickGauche, double* positionX, double* positionY, double* angle)
  22:Src/assert.c  **** { 
  33              		.loc 1 22 0
  34              		.cfi_startproc
  35              		@ args = 4, pretend = 0, frame = 0
  36              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccb54Pgm.s 			page 2


  37              	.LVL0:
  38 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
  39              	.LCFI0:
  40              		.cfi_def_cfa_offset 32
  41              		.cfi_offset 4, -32
  42              		.cfi_offset 5, -28
  43              		.cfi_offset 6, -24
  44              		.cfi_offset 7, -20
  45              		.cfi_offset 8, -16
  46              		.cfi_offset 9, -12
  47              		.cfi_offset 10, -8
  48              		.cfi_offset 14, -4
  49 0004 2DED028B 		fstmfdd	sp!, {d8}
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 40
  52              		.cfi_offset 80, -40
  53              		.cfi_offset 81, -36
  54 0008 8046     		mov	r8, r0
  55 000a 8A46     		mov	r10, r1
  56 000c 1546     		mov	r5, r2
  57 000e 1C46     		mov	r4, r3
  58 0010 DDF82890 		ldr	r9, [sp, #40]
  23:Src/assert.c  ****   // instant angle and distance
  24:Src/assert.c  ****   double dDist = (tickRight + tickGauche) / 2.0f;
  59              		.loc 1 24 0
  60 0014 4318     		adds	r3, r0, r1
  61              	.LVL1:
  62 0016 07EE903A 		fmsr	s15, r3	@ int
  63 001a F8EEE77A 		fsitos	s15, s15
  64 001e B6EE008A 		fconsts	s16, #96
  65 0022 67EE887A 		fmuls	s15, s15, s16
  66 0026 17EE900A 		fmrs	r0, s15
  67              	.LVL2:
  68 002a FFF7FEFF 		bl	__aeabi_f2d
  69              	.LVL3:
  70 002e 0646     		mov	r6, r0
  71 0030 0F46     		mov	r7, r1
  72              	.LVL4:
  25:Src/assert.c  ****   double dTheta = (tickRight - tickGauche) / 2.0f;
  73              		.loc 1 25 0
  74 0032 CAEB0808 		rsb	r8, r10, r8
  75              	.LVL5:
  76 0036 07EE908A 		fmsr	s15, r8	@ int
  77 003a F8EEE77A 		fsitos	s15, s15
  78 003e 67EE887A 		fmuls	s15, s15, s16
  79 0042 17EE900A 		fmrs	r0, s15
  80 0046 FFF7FEFF 		bl	__aeabi_f2d
  81              	.LVL6:
  26:Src/assert.c  **** 
  27:Src/assert.c  ****   // new angle
  28:Src/assert.c  ****   *angle += dTheta / ((AXISLENGTH*TICKSPERMM)/2);
  82              		.loc 1 28 0
  83 004a 24A3     		adr	r3, .L3+4
  84 004c D3E90023 		ldrd	r2, [r3]
  85 0050 FFF7FEFF 		bl	__aeabi_ddiv
  86              	.LVL7:
  87 0054 D9E90023 		ldrd	r2, [r9]
ARM GAS  /tmp/ccb54Pgm.s 			page 3


  88 0058 FFF7FEFF 		bl	__aeabi_dadd
  89              	.LVL8:
  90 005c 41EC180B 		fmdrr	d8, r0, r1
  91 0060 C9E90001 		strd	r0, [r9]
  29:Src/assert.c  **** 
  30:Src/assert.c  ****   // New X Y
  31:Src/assert.c  ****   double dX = dDist * cos(*angle);
  92              		.loc 1 31 0
  93 0064 41EC100B 		fmdrr	d0, r0, r1
  94 0068 FFF7FEFF 		bl	cos
  95              	.LVL9:
  96 006c 51EC100B 		fmrrd	r0, r1, d0
  97 0070 3246     		mov	r2, r6
  98 0072 3B46     		mov	r3, r7
  99 0074 FFF7FEFF 		bl	__aeabi_dmul
 100              	.LVL10:
 101 0078 8046     		mov	r8, r0
 102 007a 8946     		mov	r9, r1
 103              	.LVL11:
  32:Src/assert.c  ****   double dY = dDist * sin(*angle);
 104              		.loc 1 32 0
 105 007c B0EE480A 		fcpys	s0, s16
 106 0080 F0EE680A 		fcpys	s1, s17
 107 0084 FFF7FEFF 		bl	sin
 108              	.LVL12:
 109 0088 51EC100B 		fmrrd	r0, r1, d0
 110 008c 3246     		mov	r2, r6
 111 008e 3B46     		mov	r3, r7
 112 0090 FFF7FEFF 		bl	__aeabi_dmul
 113              	.LVL13:
 114 0094 0646     		mov	r6, r0
 115              	.LVL14:
 116 0096 0F46     		mov	r7, r1
 117              	.LVL15:
  33:Src/assert.c  ****   *positionX += dX / TICKSPERMM;
 118              		.loc 1 33 0
 119 0098 4046     		mov	r0, r8
 120 009a 4946     		mov	r1, r9
 121 009c 0022     		movs	r2, #0
 122 009e 0E4B     		ldr	r3, .L3
 123 00a0 FFF7FEFF 		bl	__aeabi_ddiv
 124              	.LVL16:
 125 00a4 0246     		mov	r2, r0
 126 00a6 0B46     		mov	r3, r1
 127 00a8 D5E90001 		ldrd	r0, [r5]
 128 00ac FFF7FEFF 		bl	__aeabi_dadd
 129              	.LVL17:
 130 00b0 C5E90001 		strd	r0, [r5]
  34:Src/assert.c  ****   *positionY += dY / TICKSPERMM;
 131              		.loc 1 34 0
 132 00b4 3046     		mov	r0, r6
 133 00b6 3946     		mov	r1, r7
 134 00b8 0022     		movs	r2, #0
 135 00ba 074B     		ldr	r3, .L3
 136 00bc FFF7FEFF 		bl	__aeabi_ddiv
 137              	.LVL18:
 138 00c0 0246     		mov	r2, r0
ARM GAS  /tmp/ccb54Pgm.s 			page 4


 139 00c2 0B46     		mov	r3, r1
 140 00c4 D4E90001 		ldrd	r0, [r4]
 141 00c8 FFF7FEFF 		bl	__aeabi_dadd
 142              	.LVL19:
 143 00cc C4E90001 		strd	r0, [r4]
  35:Src/assert.c  **** }
 144              		.loc 1 35 0
 145 00d0 BDEC028B 		fldmfdd	sp!, {d8}
 146              	.LCFI2:
 147              		.cfi_restore 80
 148              		.cfi_restore 81
 149              		.cfi_def_cfa_offset 32
 150 00d4 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 151              	.LVL20:
 152              	.L4:
 153              		.align	3
 154              	.L3:
 155 00d8 00003440 		.word	1077149696
 156 00dc 00000000 		.word	0
 157 00e0 00C89940 		.word	1083820032
 158              		.cfi_endproc
 159              	.LFE123:
 161              		.global	__aeabi_dcmplt
 162              		.section	.text.absPerso,"ax",%progbits
 163              		.align	2
 164              		.global	absPerso
 165              		.thumb
 166              		.thumb_func
 168              	absPerso:
 169              	.LFB126:
  36:Src/assert.c  **** 
  37:Src/assert.c  **** 
  38:Src/assert.c  **** 
  39:Src/assert.c  **** void stateMachine(int* consigneDroit, int* consigneGauche, double positionX, double positionY, doub
  40:Src/assert.c  **** {
  41:Src/assert.c  ****     static int state = 0;
  42:Src/assert.c  ****     
  43:Src/assert.c  ****     if (endOfMvt == 1)
  44:Src/assert.c  ****     {
  45:Src/assert.c  ****         endOfMvt = 0;
  46:Src/assert.c  ****         state += 1;
  47:Src/assert.c  ****     }
  48:Src/assert.c  ****     
  49:Src/assert.c  ****     switch(consignes[state])
  50:Src/assert.c  ****     {
  51:Src/assert.c  ****       case 'M':
  52:Src/assert.c  ****         move(consigneDroit, consigneGauche, positionX, positionY, angle, val1[state], val2[state], 
  53:Src/assert.c  ****         //char buffer[50] = "";
  54:Src/assert.c  **** 		//sprintf(buffer, " move %d / %d blbl\n",(int)val1[state], (int)val2[state]);
  55:Src/assert.c  **** 		//HAL_UART_Transmit(&huart2, buffer, sizeof(buffer), HAL_MAX_DELAY);
  56:Src/assert.c  ****         break;
  57:Src/assert.c  **** 
  58:Src/assert.c  ****       case 'E':  //end of the match
  59:Src/assert.c  ****         HAL_UART_Transmit(&huart2, "Fin de match", sizeof("Fin de match"), HAL_MAX_DELAY);
  60:Src/assert.c  ****         while(1){}
  61:Src/assert.c  ****         break;
  62:Src/assert.c  **** }
ARM GAS  /tmp/ccb54Pgm.s 			page 5


  63:Src/assert.c  **** }
  64:Src/assert.c  **** 
  65:Src/assert.c  **** 
  66:Src/assert.c  **** 
  67:Src/assert.c  **** 
  68:Src/assert.c  **** 
  69:Src/assert.c  **** void move(int* consigneDroit, int* consigneGauche, double positionX, double positionY, double angle
  70:Src/assert.c  **** {
  71:Src/assert.c  ****     static int isMvtDone = 0;
  72:Src/assert.c  ****     static int oldErrorDroite = 0;
  73:Src/assert.c  ****     static int errorSumDroite = 0;
  74:Src/assert.c  ****     static int oldErrorGauche = 0;
  75:Src/assert.c  ****     static int errorSumGauche = 0;
  76:Src/assert.c  ****     
  77:Src/assert.c  ****     if ((absPerso(positionX - targetX) < 50) && (absPerso(positionY - targetY) < 50))
  78:Src/assert.c  ****     {
  79:Src/assert.c  **** 		//char buffer[50] = "";
  80:Src/assert.c  **** 		//sprintf(buffer, "%d / %d\n",(int)targetX, (int)absPerso(positionY - targetY));
  81:Src/assert.c  **** 		//HAL_UART_Transmit(&huart2, buffer, sizeof(buffer), HAL_MAX_DELAY);
  82:Src/assert.c  ****         isMvtDone += 1;
  83:Src/assert.c  ****     }
  84:Src/assert.c  ****     if(isMvtDone > 500)
  85:Src/assert.c  ****     {
  86:Src/assert.c  ****         isMvtDone = 0;
  87:Src/assert.c  ****         endOfMvt = 1;
  88:Src/assert.c  ****     }
  89:Src/assert.c  ****     
  90:Src/assert.c  ****     //No ramps for the time being :/ refer to MainNucleoOLD for implementation
  91:Src/assert.c  ****     
  92:Src/assert.c  ****     
  93:Src/assert.c  ****     //need to modify the target sppeed for positionning
  94:Src/assert.c  ****     int targetSpeed = 170; //tick per ms
  95:Src/assert.c  ****     
  96:Src/assert.c  ****     int errorDroite = targetSpeed - tim5;
  97:Src/assert.c  ****     errorSumDroite += errorDroite;
  98:Src/assert.c  ****     /*//circular buffer
  99:Src/assert.c  ****     int errorSumDroite = 0;
 100:Src/assert.c  ****     static int indexBuffer = 0;
 101:Src/assert.c  ****     static int circularBuffer[100] = {0};
 102:Src/assert.c  ****     for (int i = 0; i < 100; i++) {errorSumDroite += circularBuffer[i];}
 103:Src/assert.c  ****     circularBuffer[indexBuffer] = errorDroite;
 104:Src/assert.c  ****     indexBuffer += 1;
 105:Src/assert.c  ****     if(indexBuffer > 100){indexBuffer = 0;}
 106:Src/assert.c  ****     */
 107:Src/assert.c  ****     int errorVariationDroite = errorDroite - oldErrorDroite;
 108:Src/assert.c  ****     *consigneDroit = Kp_Droite * errorDroite + Ki_Droite * errorSumDroite + Kd_Droite * errorVariat
 109:Src/assert.c  ****     oldErrorDroite = errorDroite;
 110:Src/assert.c  ****     
 111:Src/assert.c  ****     
 112:Src/assert.c  ****     int errorGauche = targetSpeed - tim4;
 113:Src/assert.c  ****     errorSumGauche += errorGauche;
 114:Src/assert.c  ****     int errorVariationGauche = errorGauche - oldErrorGauche;
 115:Src/assert.c  ****     *consigneGauche = Kp_Gauche * errorGauche + Ki_Gauche * errorSumGauche + Kd_Gauche * errorVaria
 116:Src/assert.c  ****     oldErrorGauche = errorGauche;
 117:Src/assert.c  ****     
 118:Src/assert.c  **** }
 119:Src/assert.c  **** 
ARM GAS  /tmp/ccb54Pgm.s 			page 6


 120:Src/assert.c  **** double absPerso(double x)
 121:Src/assert.c  **** {
 170              		.loc 1 121 0
 171              		.cfi_startproc
 172              		@ args = 0, pretend = 0, frame = 0
 173              		@ frame_needed = 0, uses_anonymous_args = 0
 174              	.LVL21:
 175 0000 38B5     		push	{r3, r4, r5, lr}
 176              	.LCFI3:
 177              		.cfi_def_cfa_offset 16
 178              		.cfi_offset 3, -16
 179              		.cfi_offset 4, -12
 180              		.cfi_offset 5, -8
 181              		.cfi_offset 14, -4
 182 0002 55EC104B 		fmrrd	r4, r5, d0
 122:Src/assert.c  **** 	if(x < 0) x = -x; 
 183              		.loc 1 122 0
 184 0006 10EE100A 		fmrs	r0, s0	@ int
 185 000a 2946     		mov	r1, r5
 186 000c 0022     		movs	r2, #0
 187 000e 0023     		movs	r3, #0
 188 0010 FFF7FEFF 		bl	__aeabi_dcmplt
 189              	.LVL22:
 190 0014 10B1     		cbz	r0, .L6
 191              		.loc 1 122 0 is_stmt 0 discriminator 1
 192 0016 05F10043 		add	r3, r5, #-2147483648
 193 001a 1D46     		mov	r5, r3
 194              	.LVL23:
 195              	.L6:
 123:Src/assert.c  **** 	return x;
 124:Src/assert.c  **** }
 196              		.loc 1 124 0 is_stmt 1
 197 001c 45EC104B 		fmdrr	d0, r4, r5
 198 0020 38BD     		pop	{r3, r4, r5, pc}
 199              		.cfi_endproc
 200              	.LFE126:
 202              		.global	__aeabi_dsub
 203              		.global	__aeabi_i2d
 204              		.global	__aeabi_d2iz
 205 0022 00BF     		.section	.text.move,"ax",%progbits
 206              		.align	2
 207              		.global	move
 208              		.thumb
 209              		.thumb_func
 211              	move:
 212              	.LFB125:
  70:Src/assert.c  ****     static int isMvtDone = 0;
 213              		.loc 1 70 0
 214              		.cfi_startproc
 215              		@ args = 64, pretend = 0, frame = 0
 216              		@ frame_needed = 0, uses_anonymous_args = 0
 217              	.LVL24:
 218 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 219              	.LCFI4:
 220              		.cfi_def_cfa_offset 32
 221              		.cfi_offset 4, -32
 222              		.cfi_offset 5, -28
ARM GAS  /tmp/ccb54Pgm.s 			page 7


 223              		.cfi_offset 6, -24
 224              		.cfi_offset 7, -20
 225              		.cfi_offset 8, -16
 226              		.cfi_offset 9, -12
 227              		.cfi_offset 10, -8
 228              		.cfi_offset 14, -4
 229 0004 2DED048B 		fstmfdd	sp!, {d8, d9}
 230              	.LCFI5:
 231              		.cfi_def_cfa_offset 48
 232              		.cfi_offset 80, -48
 233              		.cfi_offset 81, -44
 234              		.cfi_offset 82, -40
 235              		.cfi_offset 83, -36
 236 0008 8246     		mov	r10, r0
 237 000a 8846     		mov	r8, r1
 238 000c B0EE419A 		fcpys	s18, s2
 239 0010 F0EE619A 		fcpys	s19, s3
 240 0014 57EC126B 		fmrrd	r6, r7, d2
 241 0018 B0EE448A 		fcpys	s16, s8
 242 001c F0EE648A 		fcpys	s17, s9
 243 0020 1546     		mov	r5, r2
 244 0022 1C46     		mov	r4, r3
  77:Src/assert.c  ****     {
 245              		.loc 1 77 0
 246 0024 51EC100B 		fmrrd	r0, r1, d0
 247              	.LVL25:
 248 0028 53EC132B 		fmrrd	r2, r3, d3
 249              	.LVL26:
 250 002c FFF7FEFF 		bl	__aeabi_dsub
 251              	.LVL27:
 252 0030 41EC100B 		fmdrr	d0, r0, r1
 253 0034 FFF7FEFF 		bl	absPerso
 254              	.LVL28:
 255 0038 51EC100B 		fmrrd	r0, r1, d0
 256 003c 0022     		movs	r2, #0
 257 003e 2E4B     		ldr	r3, .L18
 258 0040 FFF7FEFF 		bl	__aeabi_dcmplt
 259              	.LVL29:
 260 0044 A0B1     		cbz	r0, .L11
  77:Src/assert.c  ****     {
 261              		.loc 1 77 0 is_stmt 0 discriminator 1
 262 0046 51EC190B 		fmrrd	r0, r1, d9
 263 004a 53EC182B 		fmrrd	r2, r3, d8
 264 004e FFF7FEFF 		bl	__aeabi_dsub
 265              	.LVL30:
 266 0052 41EC100B 		fmdrr	d0, r0, r1
 267 0056 FFF7FEFF 		bl	absPerso
 268              	.LVL31:
 269 005a 51EC100B 		fmrrd	r0, r1, d0
 270 005e 0022     		movs	r2, #0
 271 0060 254B     		ldr	r3, .L18
 272 0062 FFF7FEFF 		bl	__aeabi_dcmplt
 273              	.LVL32:
 274 0066 18B1     		cbz	r0, .L11
  82:Src/assert.c  ****     }
 275              		.loc 1 82 0 is_stmt 1
 276 0068 244A     		ldr	r2, .L18+4
ARM GAS  /tmp/ccb54Pgm.s 			page 8


 277 006a 1368     		ldr	r3, [r2]
 278 006c 0133     		adds	r3, r3, #1
 279 006e 1360     		str	r3, [r2]
 280              	.L11:
  84:Src/assert.c  ****     {
 281              		.loc 1 84 0
 282 0070 224B     		ldr	r3, .L18+4
 283 0072 1B68     		ldr	r3, [r3]
 284 0074 B3F5FA7F 		cmp	r3, #500
 285 0078 05DD     		ble	.L14
  86:Src/assert.c  ****         endOfMvt = 1;
 286              		.loc 1 86 0
 287 007a 0022     		movs	r2, #0
 288 007c 1F4B     		ldr	r3, .L18+4
 289 007e 1A60     		str	r2, [r3]
  87:Src/assert.c  ****     }
 290              		.loc 1 87 0
 291 0080 0122     		movs	r2, #1
 292 0082 1F4B     		ldr	r3, .L18+8
 293 0084 1A60     		str	r2, [r3]
 294              	.L14:
 295              	.LVL33:
  96:Src/assert.c  ****     errorSumDroite += errorDroite;
 296              		.loc 1 96 0
 297 0086 C4F1AA04 		rsb	r4, r4, #170
 298              	.LVL34:
  97:Src/assert.c  ****     /*//circular buffer
 299              		.loc 1 97 0
 300 008a 1E4A     		ldr	r2, .L18+12
 301 008c 1368     		ldr	r3, [r2]
 302 008e 2344     		add	r3, r3, r4
 303 0090 1360     		str	r3, [r2]
 304              	.LVL35:
 108:Src/assert.c  ****     oldErrorDroite = errorDroite;
 305              		.loc 1 108 0
 306 0092 04EB8409 		add	r9, r4, r4, lsl #2
 307 0096 4FEA4909 		lsl	r9, r9, #1
 308 009a 3046     		mov	r0, r6
 309 009c 3946     		mov	r1, r7
 310 009e 0022     		movs	r2, #0
 311 00a0 194B     		ldr	r3, .L18+16
 312 00a2 FFF7FEFF 		bl	__aeabi_dmul
 313              	.LVL36:
 314 00a6 0646     		mov	r6, r0
 315              	.LVL37:
 316 00a8 0F46     		mov	r7, r1
 317 00aa 4846     		mov	r0, r9
 318 00ac FFF7FEFF 		bl	__aeabi_i2d
 319              	.LVL38:
 320 00b0 3246     		mov	r2, r6
 321 00b2 3B46     		mov	r3, r7
 322 00b4 FFF7FEFF 		bl	__aeabi_dadd
 323              	.LVL39:
 324 00b8 FFF7FEFF 		bl	__aeabi_d2iz
 325              	.LVL40:
 326 00bc CAF80000 		str	r0, [r10]
 109:Src/assert.c  ****     
ARM GAS  /tmp/ccb54Pgm.s 			page 9


 327              		.loc 1 109 0
 328 00c0 124B     		ldr	r3, .L18+20
 329 00c2 1C60     		str	r4, [r3]
 112:Src/assert.c  ****     errorSumGauche += errorGauche;
 330              		.loc 1 112 0
 331 00c4 C5F1AA04 		rsb	r4, r5, #170
 332              	.LVL41:
 113:Src/assert.c  ****     int errorVariationGauche = errorGauche - oldErrorGauche;
 333              		.loc 1 113 0
 334 00c8 114A     		ldr	r2, .L18+24
 335 00ca 1368     		ldr	r3, [r2]
 336 00cc 2344     		add	r3, r3, r4
 337 00ce 1360     		str	r3, [r2]
 338              	.LVL42:
 115:Src/assert.c  ****     oldErrorGauche = errorGauche;
 339              		.loc 1 115 0
 340 00d0 04EB8400 		add	r0, r4, r4, lsl #2
 341 00d4 4000     		lsls	r0, r0, #1
 342 00d6 FFF7FEFF 		bl	__aeabi_i2d
 343              	.LVL43:
 344 00da 3246     		mov	r2, r6
 345 00dc 3B46     		mov	r3, r7
 346 00de FFF7FEFF 		bl	__aeabi_dsub
 347              	.LVL44:
 348 00e2 FFF7FEFF 		bl	__aeabi_d2iz
 349              	.LVL45:
 350 00e6 C8F80000 		str	r0, [r8]
 116:Src/assert.c  ****     
 351              		.loc 1 116 0
 352 00ea 0A4B     		ldr	r3, .L18+28
 353 00ec 1C60     		str	r4, [r3]
 118:Src/assert.c  **** 
 354              		.loc 1 118 0
 355 00ee BDEC048B 		fldmfdd	sp!, {d8-d9}
 356              	.LCFI6:
 357              		.cfi_restore 82
 358              		.cfi_restore 83
 359              		.cfi_restore 80
 360              		.cfi_restore 81
 361              		.cfi_def_cfa_offset 32
 362              	.LVL46:
 363 00f2 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 364              	.LVL47:
 365              	.L19:
 366 00f6 00BF     		.align	2
 367              	.L18:
 368 00f8 00004940 		.word	1078525952
 369 00fc 00000000 		.word	.LANCHOR0
 370 0100 00000000 		.word	.LANCHOR1
 371 0104 00000000 		.word	.LANCHOR2
 372 0108 00408F40 		.word	1083129856
 373 010c 00000000 		.word	.LANCHOR3
 374 0110 00000000 		.word	.LANCHOR4
 375 0114 00000000 		.word	.LANCHOR5
 376              		.cfi_endproc
 377              	.LFE125:
 379              		.section	.text.stateMachine,"ax",%progbits
ARM GAS  /tmp/ccb54Pgm.s 			page 10


 380              		.align	2
 381              		.global	stateMachine
 382              		.thumb
 383              		.thumb_func
 385              	stateMachine:
 386              	.LFB124:
  40:Src/assert.c  ****     static int state = 0;
 387              		.loc 1 40 0
 388              		.cfi_startproc
 389              		@ args = 64, pretend = 0, frame = 0
 390              		@ frame_needed = 0, uses_anonymous_args = 0
 391              	.LVL48:
 392 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 393              	.LCFI7:
 394              		.cfi_def_cfa_offset 20
 395              		.cfi_offset 4, -20
 396              		.cfi_offset 5, -16
 397              		.cfi_offset 6, -12
 398              		.cfi_offset 7, -8
 399              		.cfi_offset 14, -4
 400 0002 91B0     		sub	sp, sp, #68
 401              	.LCFI8:
 402              		.cfi_def_cfa_offset 88
 403 0004 8446     		mov	ip, r0
 404 0006 8E46     		mov	lr, r1
 405 0008 1746     		mov	r7, r2
 406 000a 1E46     		mov	r6, r3
  43:Src/assert.c  ****     {
 407              		.loc 1 43 0
 408 000c 1C4B     		ldr	r3, .L27
 409              	.LVL49:
 410 000e 1B68     		ldr	r3, [r3]
 411 0010 012B     		cmp	r3, #1
 412 0012 06D1     		bne	.L21
  45:Src/assert.c  ****         state += 1;
 413              		.loc 1 45 0
 414 0014 0022     		movs	r2, #0
 415              	.LVL50:
 416 0016 1A4B     		ldr	r3, .L27
 417 0018 1A60     		str	r2, [r3]
  46:Src/assert.c  ****     }
 418              		.loc 1 46 0
 419 001a 1A4A     		ldr	r2, .L27+4
 420 001c 1368     		ldr	r3, [r2]
 421 001e 0133     		adds	r3, r3, #1
 422 0020 1360     		str	r3, [r2]
 423              	.L21:
  49:Src/assert.c  ****     {
 424              		.loc 1 49 0
 425 0022 184B     		ldr	r3, .L27+4
 426 0024 1B68     		ldr	r3, [r3]
 427 0026 184A     		ldr	r2, .L27+8
 428 0028 D25C     		ldrb	r2, [r2, r3]	@ zero_extendqisi2
 429 002a 452A     		cmp	r2, #69
 430 002c 1DD0     		beq	.L23
 431 002e 4D2A     		cmp	r2, #77
 432 0030 23D1     		bne	.L20
ARM GAS  /tmp/ccb54Pgm.s 			page 11


  52:Src/assert.c  ****         //char buffer[50] = "";
 433              		.loc 1 52 0
 434 0032 DB00     		lsls	r3, r3, #3
 435 0034 154A     		ldr	r2, .L27+12
 436 0036 1A44     		add	r2, r2, r3
 437 0038 92ED003B 		fldd	d3, [r2]
 438 003c 144A     		ldr	r2, .L27+16
 439 003e 1344     		add	r3, r3, r2
 440 0040 93ED004B 		fldd	d4, [r3]
 441 0044 6C46     		mov	r4, sp
 442 0046 16AD     		add	r5, sp, #88
 443 0048 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 444              	.LVL51:
 445 004a 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 446 004c 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 447 004e 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 448 0050 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 449 0052 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 450 0054 95E80F00 		ldmia	r5, {r0, r1, r2, r3}
 451 0058 84E80F00 		stmia	r4, {r0, r1, r2, r3}
 452 005c 6046     		mov	r0, ip
 453 005e 7146     		mov	r1, lr
 454 0060 3A46     		mov	r2, r7
 455 0062 3346     		mov	r3, r6
 456 0064 FFF7FEFF 		bl	move
 457              	.LVL52:
  56:Src/assert.c  **** 
 458              		.loc 1 56 0
 459 0068 07E0     		b	.L20
 460              	.LVL53:
 461              	.L23:
  59:Src/assert.c  ****         while(1){}
 462              		.loc 1 59 0
 463 006a 16A8     		add	r0, sp, #88
 464              	.LVL54:
 465 006c 0949     		ldr	r1, .L27+20
 466              	.LVL55:
 467 006e 0D22     		movs	r2, #13
 468 0070 4FF0FF33 		mov	r3, #-1
 469 0074 FFF7FEFF 		bl	HAL_UART_Transmit
 470              	.LVL56:
 471              	.L25:
  60:Src/assert.c  ****         break;
 472              		.loc 1 60 0 discriminator 1
 473 0078 FEE7     		b	.L25
 474              	.L20:
  63:Src/assert.c  **** 
 475              		.loc 1 63 0
 476 007a 11B0     		add	sp, sp, #68
 477              	.LCFI9:
 478              		.cfi_def_cfa_offset 20
 479              		@ sp needed
 480 007c F0BD     		pop	{r4, r5, r6, r7, pc}
 481              	.LVL57:
 482              	.L28:
 483 007e 00BF     		.align	2
 484              	.L27:
ARM GAS  /tmp/ccb54Pgm.s 			page 12


 485 0080 00000000 		.word	.LANCHOR1
 486 0084 00000000 		.word	.LANCHOR6
 487 0088 00000000 		.word	.LANCHOR7
 488 008c 00000000 		.word	.LANCHOR8
 489 0090 00000000 		.word	.LANCHOR9
 490 0094 00000000 		.word	.LC0
 491              		.cfi_endproc
 492              	.LFE124:
 494              		.global	endOfMvt
 495              		.global	val2
 496              		.global	val1
 497              		.global	consignes
 498              		.section	.bss.oldErrorDroite.7926,"aw",%nobits
 499              		.align	2
 500              		.set	.LANCHOR3,. + 0
 503              	oldErrorDroite.7926:
 504 0000 00000000 		.space	4
 505              		.section	.data.val1,"aw",%progbits
 506              		.align	3
 507              		.set	.LANCHOR8,. + 0
 510              	val1:
 511 0000 00000000 		.word	0
 512 0004 00409F40 		.word	1084178432
 513 0008 00000000 		.word	0
 514 000c 00000000 		.word	0
 515              		.section	.bss.oldErrorGauche.7928,"aw",%nobits
 516              		.align	2
 517              		.set	.LANCHOR5,. + 0
 520              	oldErrorGauche.7928:
 521 0000 00000000 		.space	4
 522              		.section	.bss.state.7908,"aw",%nobits
 523              		.align	2
 524              		.set	.LANCHOR6,. + 0
 527              	state.7908:
 528 0000 00000000 		.space	4
 529              		.section	.bss.errorSumDroite.7927,"aw",%nobits
 530              		.align	2
 531              		.set	.LANCHOR2,. + 0
 534              	errorSumDroite.7927:
 535 0000 00000000 		.space	4
 536              		.section	.bss.val2,"aw",%nobits
 537              		.align	3
 538              		.set	.LANCHOR9,. + 0
 541              	val2:
 542 0000 00000000 		.space	16
 542      00000000 
 542      00000000 
 542      00000000 
 543              		.section	.rodata.str1.4,"aMS",%progbits,1
 544              		.align	2
 545              	.LC0:
 546 0000 46696E20 		.ascii	"Fin de match\000"
 546      6465206D 
 546      61746368 
 546      00
 547              		.section	.bss.isMvtDone.7925,"aw",%nobits
 548              		.align	2
ARM GAS  /tmp/ccb54Pgm.s 			page 13


 549              		.set	.LANCHOR0,. + 0
 552              	isMvtDone.7925:
 553 0000 00000000 		.space	4
 554              		.section	.bss.endOfMvt,"aw",%nobits
 555              		.align	2
 556              		.set	.LANCHOR1,. + 0
 559              	endOfMvt:
 560 0000 00000000 		.space	4
 561              		.section	.bss.errorSumGauche.7929,"aw",%nobits
 562              		.align	2
 563              		.set	.LANCHOR4,. + 0
 566              	errorSumGauche.7929:
 567 0000 00000000 		.space	4
 568              		.section	.data.consignes,"aw",%progbits
 569              		.align	2
 570              		.set	.LANCHOR7,. + 0
 573              	consignes:
 574 0000 4D       		.byte	77
 575 0001 45       		.byte	69
 576              		.text
 577              	.Letext0:
 578              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 579              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 580              		.file 4 "Drivers/CMSIS/Device/ST/STM32F4xx/Include/stm32f401xe.h"
 581              		.file 5 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_def.h"
 582              		.file 6 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_dma.h"
 583              		.file 7 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_uart.h"
 584              		.file 8 "Drivers/CMSIS/Include/core_cm4.h"
 585              		.file 9 "/usr/include/newlib/math.h"
ARM GAS  /tmp/ccb54Pgm.s 			page 14


DEFINED SYMBOLS
                            *ABS*:0000000000000000 assert.c
     /tmp/ccb54Pgm.s:25     .text.updatePos:0000000000000000 $t
     /tmp/ccb54Pgm.s:30     .text.updatePos:0000000000000000 updatePos
     /tmp/ccb54Pgm.s:155    .text.updatePos:00000000000000d8 $d
     /tmp/ccb54Pgm.s:163    .text.absPerso:0000000000000000 $t
     /tmp/ccb54Pgm.s:168    .text.absPerso:0000000000000000 absPerso
     /tmp/ccb54Pgm.s:206    .text.move:0000000000000000 $t
     /tmp/ccb54Pgm.s:211    .text.move:0000000000000000 move
     /tmp/ccb54Pgm.s:368    .text.move:00000000000000f8 $d
     /tmp/ccb54Pgm.s:380    .text.stateMachine:0000000000000000 $t
     /tmp/ccb54Pgm.s:385    .text.stateMachine:0000000000000000 stateMachine
     /tmp/ccb54Pgm.s:485    .text.stateMachine:0000000000000080 $d
     /tmp/ccb54Pgm.s:559    .bss.endOfMvt:0000000000000000 endOfMvt
     /tmp/ccb54Pgm.s:541    .bss.val2:0000000000000000 val2
     /tmp/ccb54Pgm.s:510    .data.val1:0000000000000000 val1
     /tmp/ccb54Pgm.s:573    .data.consignes:0000000000000000 consignes
     /tmp/ccb54Pgm.s:499    .bss.oldErrorDroite.7926:0000000000000000 $d
     /tmp/ccb54Pgm.s:503    .bss.oldErrorDroite.7926:0000000000000000 oldErrorDroite.7926
     /tmp/ccb54Pgm.s:506    .data.val1:0000000000000000 $d
     /tmp/ccb54Pgm.s:516    .bss.oldErrorGauche.7928:0000000000000000 $d
     /tmp/ccb54Pgm.s:520    .bss.oldErrorGauche.7928:0000000000000000 oldErrorGauche.7928
     /tmp/ccb54Pgm.s:523    .bss.state.7908:0000000000000000 $d
     /tmp/ccb54Pgm.s:527    .bss.state.7908:0000000000000000 state.7908
     /tmp/ccb54Pgm.s:530    .bss.errorSumDroite.7927:0000000000000000 $d
     /tmp/ccb54Pgm.s:534    .bss.errorSumDroite.7927:0000000000000000 errorSumDroite.7927
     /tmp/ccb54Pgm.s:537    .bss.val2:0000000000000000 $d
     /tmp/ccb54Pgm.s:544    .rodata.str1.4:0000000000000000 $d
     /tmp/ccb54Pgm.s:548    .bss.isMvtDone.7925:0000000000000000 $d
     /tmp/ccb54Pgm.s:552    .bss.isMvtDone.7925:0000000000000000 isMvtDone.7925
     /tmp/ccb54Pgm.s:555    .bss.endOfMvt:0000000000000000 $d
     /tmp/ccb54Pgm.s:562    .bss.errorSumGauche.7929:0000000000000000 $d
     /tmp/ccb54Pgm.s:566    .bss.errorSumGauche.7929:0000000000000000 errorSumGauche.7929
     /tmp/ccb54Pgm.s:569    .data.consignes:0000000000000000 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
__aeabi_f2d
__aeabi_ddiv
__aeabi_dadd
__aeabi_dmul
cos
sin
__aeabi_dcmplt
__aeabi_dsub
__aeabi_i2d
__aeabi_d2iz
HAL_UART_Transmit
