ARM GAS  /tmp/ccgp9pkP.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 1
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.file	"assert.c"
  17              		.text
  18              	.Ltext0:
  19              		.cfi_sections	.debug_frame
  20              		.global	__aeabi_f2d
  21              		.global	__aeabi_ddiv
  22              		.global	__aeabi_dadd
  23              		.global	__aeabi_dmul
  24              		.section	.text.updatePos,"ax",%progbits
  25              		.align	2
  26              		.global	updatePos
  27              		.thumb
  28              		.thumb_func
  30              	updatePos:
  31              	.LFB123:
  32              		.file 1 "Src/assert.c"
   1:Src/assert.c  **** #include "assert.h"
   2:Src/assert.c  **** 
   3:Src/assert.c  **** #define Kp_Droite 10
   4:Src/assert.c  **** #define Ki_Droite 0
   5:Src/assert.c  **** #define Kd_Droite 0
   6:Src/assert.c  **** 
   7:Src/assert.c  **** 
   8:Src/assert.c  **** #define Kp_Gauche 10
   9:Src/assert.c  **** #define Ki_Gauche 0
  10:Src/assert.c  **** #define Kd_Gauche 0
  11:Src/assert.c  **** 
  12:Src/assert.c  **** #define Kp_Angle 1000
  13:Src/assert.c  **** 
  14:Src/assert.c  **** char consignes[] = {'M','A','M', 'A', 'M','E'};
  15:Src/assert.c  **** double val1[] = { 10, 0.5, 10, -1.0,10, 0 };
  16:Src/assert.c  **** double val2[] = { 0, 0, 0 ,0, 0, 0 };
  17:Src/assert.c  **** 
  18:Src/assert.c  **** int endOfMvt = 0;
  19:Src/assert.c  **** 
  20:Src/assert.c  **** 
  21:Src/assert.c  **** void updatePos(int tickRight, int tickGauche, double* positionX, double* positionY, double* angle)
  22:Src/assert.c  **** { 
  33              		.loc 1 22 0
  34              		.cfi_startproc
  35              		@ args = 4, pretend = 0, frame = 0
  36              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccgp9pkP.s 			page 2


  37              	.LVL0:
  38 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
  39              	.LCFI0:
  40              		.cfi_def_cfa_offset 32
  41              		.cfi_offset 4, -32
  42              		.cfi_offset 5, -28
  43              		.cfi_offset 6, -24
  44              		.cfi_offset 7, -20
  45              		.cfi_offset 8, -16
  46              		.cfi_offset 9, -12
  47              		.cfi_offset 10, -8
  48              		.cfi_offset 14, -4
  49 0004 2DED028B 		fstmfdd	sp!, {d8}
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 40
  52              		.cfi_offset 80, -40
  53              		.cfi_offset 81, -36
  54 0008 8046     		mov	r8, r0
  55 000a 8A46     		mov	r10, r1
  56 000c 1546     		mov	r5, r2
  57 000e 1C46     		mov	r4, r3
  58 0010 DDF82890 		ldr	r9, [sp, #40]
  23:Src/assert.c  ****   // instant angle and distance
  24:Src/assert.c  ****   double dDist = (tickRight + tickGauche) / 2.0f;
  59              		.loc 1 24 0
  60 0014 4318     		adds	r3, r0, r1
  61              	.LVL1:
  62 0016 07EE903A 		fmsr	s15, r3	@ int
  63 001a F8EEE77A 		fsitos	s15, s15
  64 001e B6EE008A 		fconsts	s16, #96
  65 0022 67EE887A 		fmuls	s15, s15, s16
  66 0026 17EE900A 		fmrs	r0, s15
  67              	.LVL2:
  68 002a FFF7FEFF 		bl	__aeabi_f2d
  69              	.LVL3:
  70 002e 0646     		mov	r6, r0
  71 0030 0F46     		mov	r7, r1
  72              	.LVL4:
  25:Src/assert.c  ****   double dTheta = (tickRight - tickGauche) / 2.0f;
  73              		.loc 1 25 0
  74 0032 CAEB0808 		rsb	r8, r10, r8
  75              	.LVL5:
  76 0036 07EE908A 		fmsr	s15, r8	@ int
  77 003a F8EEE77A 		fsitos	s15, s15
  78 003e 67EE887A 		fmuls	s15, s15, s16
  79 0042 17EE900A 		fmrs	r0, s15
  80 0046 FFF7FEFF 		bl	__aeabi_f2d
  81              	.LVL6:
  26:Src/assert.c  **** 
  27:Src/assert.c  ****   // new angle
  28:Src/assert.c  ****   *angle += dTheta / ((AXISLENGTH*TICKSPERMM)/2);
  82              		.loc 1 28 0
  83 004a 24A3     		adr	r3, .L3+4
  84 004c D3E90023 		ldrd	r2, [r3]
  85 0050 FFF7FEFF 		bl	__aeabi_ddiv
  86              	.LVL7:
  87 0054 D9E90023 		ldrd	r2, [r9]
ARM GAS  /tmp/ccgp9pkP.s 			page 3


  88 0058 FFF7FEFF 		bl	__aeabi_dadd
  89              	.LVL8:
  90 005c 41EC180B 		fmdrr	d8, r0, r1
  91 0060 C9E90001 		strd	r0, [r9]
  29:Src/assert.c  **** 
  30:Src/assert.c  ****   // New X Y
  31:Src/assert.c  ****   double dX = dDist * cos(*angle);
  92              		.loc 1 31 0
  93 0064 41EC100B 		fmdrr	d0, r0, r1
  94 0068 FFF7FEFF 		bl	cos
  95              	.LVL9:
  96 006c 51EC100B 		fmrrd	r0, r1, d0
  97 0070 3246     		mov	r2, r6
  98 0072 3B46     		mov	r3, r7
  99 0074 FFF7FEFF 		bl	__aeabi_dmul
 100              	.LVL10:
 101 0078 8046     		mov	r8, r0
 102 007a 8946     		mov	r9, r1
 103              	.LVL11:
  32:Src/assert.c  ****   double dY = dDist * sin(*angle);
 104              		.loc 1 32 0
 105 007c B0EE480A 		fcpys	s0, s16
 106 0080 F0EE680A 		fcpys	s1, s17
 107 0084 FFF7FEFF 		bl	sin
 108              	.LVL12:
 109 0088 51EC100B 		fmrrd	r0, r1, d0
 110 008c 3246     		mov	r2, r6
 111 008e 3B46     		mov	r3, r7
 112 0090 FFF7FEFF 		bl	__aeabi_dmul
 113              	.LVL13:
 114 0094 0646     		mov	r6, r0
 115              	.LVL14:
 116 0096 0F46     		mov	r7, r1
 117              	.LVL15:
  33:Src/assert.c  ****   *positionX += dX / TICKSPERMM;
 118              		.loc 1 33 0
 119 0098 4046     		mov	r0, r8
 120 009a 4946     		mov	r1, r9
 121 009c 0022     		movs	r2, #0
 122 009e 0E4B     		ldr	r3, .L3
 123 00a0 FFF7FEFF 		bl	__aeabi_ddiv
 124              	.LVL16:
 125 00a4 0246     		mov	r2, r0
 126 00a6 0B46     		mov	r3, r1
 127 00a8 D5E90001 		ldrd	r0, [r5]
 128 00ac FFF7FEFF 		bl	__aeabi_dadd
 129              	.LVL17:
 130 00b0 C5E90001 		strd	r0, [r5]
  34:Src/assert.c  ****   *positionY += dY / TICKSPERMM;
 131              		.loc 1 34 0
 132 00b4 3046     		mov	r0, r6
 133 00b6 3946     		mov	r1, r7
 134 00b8 0022     		movs	r2, #0
 135 00ba 074B     		ldr	r3, .L3
 136 00bc FFF7FEFF 		bl	__aeabi_ddiv
 137              	.LVL18:
 138 00c0 0246     		mov	r2, r0
ARM GAS  /tmp/ccgp9pkP.s 			page 4


 139 00c2 0B46     		mov	r3, r1
 140 00c4 D4E90001 		ldrd	r0, [r4]
 141 00c8 FFF7FEFF 		bl	__aeabi_dadd
 142              	.LVL19:
 143 00cc C4E90001 		strd	r0, [r4]
  35:Src/assert.c  **** }
 144              		.loc 1 35 0
 145 00d0 BDEC028B 		fldmfdd	sp!, {d8}
 146              	.LCFI2:
 147              		.cfi_restore 80
 148              		.cfi_restore 81
 149              		.cfi_def_cfa_offset 32
 150 00d4 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 151              	.LVL20:
 152              	.L4:
 153              		.align	3
 154              	.L3:
 155 00d8 00003440 		.word	1077149696
 156 00dc 00000000 		.word	0
 157 00e0 00C89940 		.word	1083820032
 158              		.cfi_endproc
 159              	.LFE123:
 161              		.global	__aeabi_dcmplt
 162              		.section	.text.absPerso,"ax",%progbits
 163              		.align	2
 164              		.global	absPerso
 165              		.thumb
 166              		.thumb_func
 168              	absPerso:
 169              	.LFB127:
  36:Src/assert.c  **** 
  37:Src/assert.c  **** 
  38:Src/assert.c  **** 
  39:Src/assert.c  **** void stateMachine(int* consigneDroit, int* consigneGauche, double positionX, double positionY, doub
  40:Src/assert.c  **** {
  41:Src/assert.c  ****     static int state = 0;
  42:Src/assert.c  ****     
  43:Src/assert.c  ****     if (endOfMvt == 1)
  44:Src/assert.c  ****     {
  45:Src/assert.c  ****         endOfMvt = 0;
  46:Src/assert.c  ****         state += 1;
  47:Src/assert.c  ****         HAL_UART_Transmit(&huart2, "Fin de l'action\n", sizeof("Fin de l'action\n"), HAL_MAX_DELAY)
  48:Src/assert.c  ****     }
  49:Src/assert.c  ****     
  50:Src/assert.c  ****     switch(consignes[state])
  51:Src/assert.c  ****     {
  52:Src/assert.c  ****       case 'M':
  53:Src/assert.c  ****         move(consigneDroit, consigneGauche, positionX, positionY, angle, val1[state], val2[state], 
  54:Src/assert.c  ****         //char buffer[50] = "";
  55:Src/assert.c  **** 		//sprintf(buffer, " move %d / %d blbl\n",(int)val1[state], (int)val2[state]);
  56:Src/assert.c  **** 		//HAL_UART_Transmit(&huart2, buffer, sizeof(buffer), HAL_MAX_DELAY);
  57:Src/assert.c  ****         break;
  58:Src/assert.c  ****         
  59:Src/assert.c  ****       case 'A':
  60:Src/assert.c  **** 		turn(consigneDroit, consigneGauche, positionX, positionY, angle, val1[state], val2[state], tim4, 
  61:Src/assert.c  **** 		break;
  62:Src/assert.c  **** 
ARM GAS  /tmp/ccgp9pkP.s 			page 5


  63:Src/assert.c  ****       case 'E':  //end of the match
  64:Src/assert.c  ****         HAL_UART_Transmit(&huart2, "Fin de match\n", sizeof("Fin de match\n"), HAL_MAX_DELAY);
  65:Src/assert.c  ****         while(1){}
  66:Src/assert.c  ****         break;
  67:Src/assert.c  **** }
  68:Src/assert.c  **** }
  69:Src/assert.c  **** 
  70:Src/assert.c  **** 
  71:Src/assert.c  **** void turn(int* consigneDroit, int* consigneGauche, double positionX, double positionY, double angle
  72:Src/assert.c  **** {
  73:Src/assert.c  **** 	//char buffer[50] = "";
  74:Src/assert.c  **** 	//sprintf(buffer, "%g / %g / %g\n",targetX, angle, absPerso(angle - targetX));
  75:Src/assert.c  **** 	//HAL_UART_Transmit(&huart2, buffer, sizeof(buffer), HAL_MAX_DELAY);
  76:Src/assert.c  **** 	
  77:Src/assert.c  **** 	if ( absPerso(angle) < absPerso(targetX))
  78:Src/assert.c  ****     {
  79:Src/assert.c  **** 		if(targetX > 0)
  80:Src/assert.c  **** 		{
  81:Src/assert.c  **** 			*consigneGauche = 1000;
  82:Src/assert.c  **** 			*consigneDroit = -1000;
  83:Src/assert.c  **** 		}
  84:Src/assert.c  **** 		else
  85:Src/assert.c  **** 		{
  86:Src/assert.c  **** 			*consigneGauche = -1000;
  87:Src/assert.c  **** 			*consigneDroit = 1000;
  88:Src/assert.c  **** 		}
  89:Src/assert.c  **** 	}
  90:Src/assert.c  **** 	else
  91:Src/assert.c  **** 	{
  92:Src/assert.c  **** 		*consigneGauche = 0;
  93:Src/assert.c  **** 		*consigneDroit = 0;
  94:Src/assert.c  **** 		endOfMvt = 1;
  95:Src/assert.c  ****     }
  96:Src/assert.c  **** }
  97:Src/assert.c  **** 
  98:Src/assert.c  **** 
  99:Src/assert.c  **** void move(int* consigneDroit, int* consigneGauche, double positionX, double positionY, double angle
 100:Src/assert.c  **** {
 101:Src/assert.c  ****     static int isMvtDone = 0;
 102:Src/assert.c  ****     static int oldErrorDroite = 0;
 103:Src/assert.c  ****     static int errorSumDroite = 0;
 104:Src/assert.c  ****     static int oldErrorGauche = 0;
 105:Src/assert.c  ****     static int errorSumGauche = 0;
 106:Src/assert.c  ****     
 107:Src/assert.c  ****     
 108:Src/assert.c  ****     if ((absPerso(positionX - targetX) < 50) && (absPerso(positionY - targetY) < 50))
 109:Src/assert.c  ****     {
 110:Src/assert.c  **** 		//char buffer[50] = "";
 111:Src/assert.c  **** 		//sprintf(buffer, "%d / %d\n",(int)targetX, (int)absPerso(positionY - targetY));
 112:Src/assert.c  **** 		//HAL_UART_Transmit(&huart2, buffer, sizeof(buffer), HAL_MAX_DELAY);
 113:Src/assert.c  ****         isMvtDone += 1;
 114:Src/assert.c  ****     }
 115:Src/assert.c  ****     if(isMvtDone > 5)
 116:Src/assert.c  ****     {
 117:Src/assert.c  ****         isMvtDone = 0;
 118:Src/assert.c  ****         endOfMvt = 1;
 119:Src/assert.c  ****         *consigneDroit = 0;
ARM GAS  /tmp/ccgp9pkP.s 			page 6


 120:Src/assert.c  ****         *consigneGauche = 0;
 121:Src/assert.c  ****     }
 122:Src/assert.c  ****     else
 123:Src/assert.c  ****     {
 124:Src/assert.c  **** 		//No ramps for the time being :/ refer to MainNucleoOLD for implementation
 125:Src/assert.c  **** 		
 126:Src/assert.c  **** 		
 127:Src/assert.c  **** 		//need to modify the target sppeed for positionning
 128:Src/assert.c  **** 		int targetSpeed = 170; //tick per ms
 129:Src/assert.c  **** 		
 130:Src/assert.c  **** 		int errorDroite = targetSpeed - tim5;
 131:Src/assert.c  **** 		errorSumDroite += errorDroite;
 132:Src/assert.c  **** 		/*//circular buffer
 133:Src/assert.c  **** 		int errorSumDroite = 0;
 134:Src/assert.c  **** 		static int indexBuffer = 0;
 135:Src/assert.c  **** 		static int circularBuffer[100] = {0};
 136:Src/assert.c  **** 		for (int i = 0; i < 100; i++) {errorSumDroite += circularBuffer[i];}
 137:Src/assert.c  **** 		circularBuffer[indexBuffer] = errorDroite;
 138:Src/assert.c  **** 		indexBuffer += 1;
 139:Src/assert.c  **** 		if(indexBuffer > 100){indexBuffer = 0;}
 140:Src/assert.c  **** 		*/
 141:Src/assert.c  **** 		int errorVariationDroite = errorDroite - oldErrorDroite;
 142:Src/assert.c  **** 		*consigneDroit = Kp_Droite * errorDroite + Ki_Droite * errorSumDroite + Kd_Droite * errorVariatio
 143:Src/assert.c  **** 		oldErrorDroite = errorDroite;
 144:Src/assert.c  **** 		
 145:Src/assert.c  **** 		
 146:Src/assert.c  **** 		int errorGauche = targetSpeed - tim4;
 147:Src/assert.c  **** 		errorSumGauche += errorGauche;
 148:Src/assert.c  **** 		int errorVariationGauche = errorGauche - oldErrorGauche;
 149:Src/assert.c  **** 		*consigneGauche = Kp_Gauche * errorGauche + Ki_Gauche * errorSumGauche + Kd_Gauche * errorVariati
 150:Src/assert.c  **** 		oldErrorGauche = errorGauche;
 151:Src/assert.c  **** 	}
 152:Src/assert.c  ****     
 153:Src/assert.c  **** }
 154:Src/assert.c  **** 
 155:Src/assert.c  **** double absPerso(double x)
 156:Src/assert.c  **** {
 170              		.loc 1 156 0
 171              		.cfi_startproc
 172              		@ args = 0, pretend = 0, frame = 0
 173              		@ frame_needed = 0, uses_anonymous_args = 0
 174              	.LVL21:
 175 0000 38B5     		push	{r3, r4, r5, lr}
 176              	.LCFI3:
 177              		.cfi_def_cfa_offset 16
 178              		.cfi_offset 3, -16
 179              		.cfi_offset 4, -12
 180              		.cfi_offset 5, -8
 181              		.cfi_offset 14, -4
 182 0002 55EC104B 		fmrrd	r4, r5, d0
 157:Src/assert.c  **** 	if(x < 0) x = -x; 
 183              		.loc 1 157 0
 184 0006 10EE100A 		fmrs	r0, s0	@ int
 185 000a 2946     		mov	r1, r5
 186 000c 0022     		movs	r2, #0
 187 000e 0023     		movs	r3, #0
 188 0010 FFF7FEFF 		bl	__aeabi_dcmplt
ARM GAS  /tmp/ccgp9pkP.s 			page 7


 189              	.LVL22:
 190 0014 10B1     		cbz	r0, .L6
 191              		.loc 1 157 0 is_stmt 0 discriminator 1
 192 0016 05F10043 		add	r3, r5, #-2147483648
 193 001a 1D46     		mov	r5, r3
 194              	.LVL23:
 195              	.L6:
 158:Src/assert.c  **** 	return x;
 159:Src/assert.c  **** }
 196              		.loc 1 159 0 is_stmt 1
 197 001c 45EC104B 		fmdrr	d0, r4, r5
 198 0020 38BD     		pop	{r3, r4, r5, pc}
 199              		.cfi_endproc
 200              	.LFE127:
 202              		.global	__aeabi_dcmpgt
 203 0022 00BF     		.section	.text.turn,"ax",%progbits
 204              		.align	2
 205              		.global	turn
 206              		.thumb
 207              		.thumb_func
 209              	turn:
 210              	.LFB125:
  72:Src/assert.c  **** 	//char buffer[50] = "";
 211              		.loc 1 72 0
 212              		.cfi_startproc
 213              		@ args = 64, pretend = 0, frame = 0
 214              		@ frame_needed = 0, uses_anonymous_args = 0
 215              	.LVL24:
 216 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 217              	.LCFI4:
 218              		.cfi_def_cfa_offset 24
 219              		.cfi_offset 3, -24
 220              		.cfi_offset 4, -20
 221              		.cfi_offset 5, -16
 222              		.cfi_offset 6, -12
 223              		.cfi_offset 7, -8
 224              		.cfi_offset 14, -4
 225 0002 2DED028B 		fstmfdd	sp!, {d8}
 226              	.LCFI5:
 227              		.cfi_def_cfa_offset 32
 228              		.cfi_offset 80, -32
 229              		.cfi_offset 81, -28
 230 0006 0446     		mov	r4, r0
 231 0008 0D46     		mov	r5, r1
 232 000a B0EE438A 		fcpys	s16, s6
 233 000e F0EE638A 		fcpys	s17, s7
  77:Src/assert.c  ****     {
 234              		.loc 1 77 0
 235 0012 B0EE420A 		fcpys	s0, s4
 236 0016 F0EE620A 		fcpys	s1, s5
 237              	.LVL25:
 238 001a FFF7FEFF 		bl	absPerso
 239              	.LVL26:
 240 001e 57EC106B 		fmrrd	r6, r7, d0
 241 0022 B0EE480A 		fcpys	s0, s16
 242 0026 F0EE680A 		fcpys	s1, s17
 243 002a FFF7FEFF 		bl	absPerso
ARM GAS  /tmp/ccgp9pkP.s 			page 8


 244              	.LVL27:
 245 002e 3046     		mov	r0, r6
 246 0030 3946     		mov	r1, r7
 247 0032 53EC102B 		fmrrd	r2, r3, d0
 248 0036 FFF7FEFF 		bl	__aeabi_dcmplt
 249              	.LVL28:
 250 003a 98B1     		cbz	r0, .L18
  79:Src/assert.c  **** 		{
 251              		.loc 1 79 0
 252 003c 51EC180B 		fmrrd	r0, r1, d8
 253 0040 0022     		movs	r2, #0
 254 0042 0023     		movs	r3, #0
 255 0044 FFF7FEFF 		bl	__aeabi_dcmpgt
 256              	.LVL29:
 257 0048 30B1     		cbz	r0, .L19
  81:Src/assert.c  **** 			*consigneDroit = -1000;
 258              		.loc 1 81 0
 259 004a 4FF47A73 		mov	r3, #1000
 260 004e 2B60     		str	r3, [r5]
  82:Src/assert.c  **** 		}
 261              		.loc 1 82 0
 262 0050 A3F5FA63 		sub	r3, r3, #2000
 263 0054 2360     		str	r3, [r4]
 264 0056 0BE0     		b	.L10
 265              	.L19:
  86:Src/assert.c  **** 			*consigneDroit = 1000;
 266              		.loc 1 86 0
 267 0058 074B     		ldr	r3, .L21
 268 005a 2B60     		str	r3, [r5]
  87:Src/assert.c  **** 		}
 269              		.loc 1 87 0
 270 005c 4FF47A73 		mov	r3, #1000
 271 0060 2360     		str	r3, [r4]
 272 0062 05E0     		b	.L10
 273              	.L18:
  92:Src/assert.c  **** 		*consigneDroit = 0;
 274              		.loc 1 92 0
 275 0064 0023     		movs	r3, #0
 276 0066 2B60     		str	r3, [r5]
  93:Src/assert.c  **** 		endOfMvt = 1;
 277              		.loc 1 93 0
 278 0068 2360     		str	r3, [r4]
  94:Src/assert.c  ****     }
 279              		.loc 1 94 0
 280 006a 0122     		movs	r2, #1
 281 006c 034B     		ldr	r3, .L21+4
 282 006e 1A60     		str	r2, [r3]
 283              	.L10:
  96:Src/assert.c  **** 
 284              		.loc 1 96 0
 285 0070 BDEC028B 		fldmfdd	sp!, {d8}
 286              	.LCFI6:
 287              		.cfi_restore 80
 288              		.cfi_restore 81
 289              		.cfi_def_cfa_offset 24
 290              	.LVL30:
 291 0074 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
ARM GAS  /tmp/ccgp9pkP.s 			page 9


 292              	.LVL31:
 293              	.L22:
 294 0076 00BF     		.align	2
 295              	.L21:
 296 0078 18FCFFFF 		.word	-1000
 297 007c 00000000 		.word	.LANCHOR0
 298              		.cfi_endproc
 299              	.LFE125:
 301              		.global	__aeabi_dsub
 302              		.global	__aeabi_i2d
 303              		.global	__aeabi_d2iz
 304              		.section	.text.move,"ax",%progbits
 305              		.align	2
 306              		.global	move
 307              		.thumb
 308              		.thumb_func
 310              	move:
 311              	.LFB126:
 100:Src/assert.c  ****     static int isMvtDone = 0;
 312              		.loc 1 100 0
 313              		.cfi_startproc
 314              		@ args = 64, pretend = 0, frame = 0
 315              		@ frame_needed = 0, uses_anonymous_args = 0
 316              	.LVL32:
 317 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 318              	.LCFI7:
 319              		.cfi_def_cfa_offset 32
 320              		.cfi_offset 4, -32
 321              		.cfi_offset 5, -28
 322              		.cfi_offset 6, -24
 323              		.cfi_offset 7, -20
 324              		.cfi_offset 8, -16
 325              		.cfi_offset 9, -12
 326              		.cfi_offset 10, -8
 327              		.cfi_offset 14, -4
 328 0004 2DED068B 		fstmfdd	sp!, {d8, d9, d10}
 329              	.LCFI8:
 330              		.cfi_def_cfa_offset 56
 331              		.cfi_offset 80, -56
 332              		.cfi_offset 81, -52
 333              		.cfi_offset 82, -48
 334              		.cfi_offset 83, -44
 335              		.cfi_offset 84, -40
 336              		.cfi_offset 85, -36
 337 0008 8246     		mov	r10, r0
 338 000a 8846     		mov	r8, r1
 339 000c B0EE41AA 		fcpys	s20, s2
 340 0010 F0EE61AA 		fcpys	s21, s3
 341 0014 B0EE428A 		fcpys	s16, s4
 342 0018 F0EE628A 		fcpys	s17, s5
 343 001c B0EE449A 		fcpys	s18, s8
 344 0020 F0EE649A 		fcpys	s19, s9
 345 0024 1546     		mov	r5, r2
 346 0026 1C46     		mov	r4, r3
 108:Src/assert.c  ****     {
 347              		.loc 1 108 0
 348 0028 51EC100B 		fmrrd	r0, r1, d0
ARM GAS  /tmp/ccgp9pkP.s 			page 10


 349              	.LVL33:
 350 002c 53EC132B 		fmrrd	r2, r3, d3
 351              	.LVL34:
 352 0030 FFF7FEFF 		bl	__aeabi_dsub
 353              	.LVL35:
 354 0034 41EC100B 		fmdrr	d0, r0, r1
 355 0038 FFF7FEFF 		bl	absPerso
 356              	.LVL36:
 357 003c 51EC100B 		fmrrd	r0, r1, d0
 358 0040 0022     		movs	r2, #0
 359 0042 304B     		ldr	r3, .L32
 360 0044 FFF7FEFF 		bl	__aeabi_dcmplt
 361              	.LVL37:
 362 0048 A0B1     		cbz	r0, .L24
 108:Src/assert.c  ****     {
 363              		.loc 1 108 0 is_stmt 0 discriminator 1
 364 004a 51EC1A0B 		fmrrd	r0, r1, d10
 365 004e 53EC192B 		fmrrd	r2, r3, d9
 366 0052 FFF7FEFF 		bl	__aeabi_dsub
 367              	.LVL38:
 368 0056 41EC100B 		fmdrr	d0, r0, r1
 369 005a FFF7FEFF 		bl	absPerso
 370              	.LVL39:
 371 005e 51EC100B 		fmrrd	r0, r1, d0
 372 0062 0022     		movs	r2, #0
 373 0064 274B     		ldr	r3, .L32
 374 0066 FFF7FEFF 		bl	__aeabi_dcmplt
 375              	.LVL40:
 376 006a 18B1     		cbz	r0, .L24
 113:Src/assert.c  ****     }
 377              		.loc 1 113 0 is_stmt 1
 378 006c 264A     		ldr	r2, .L32+4
 379 006e 1368     		ldr	r3, [r2]
 380 0070 0133     		adds	r3, r3, #1
 381 0072 1360     		str	r3, [r2]
 382              	.L24:
 115:Src/assert.c  ****     {
 383              		.loc 1 115 0
 384 0074 244B     		ldr	r3, .L32+4
 385 0076 1B68     		ldr	r3, [r3]
 386 0078 052B     		cmp	r3, #5
 387 007a 0ADD     		ble	.L27
 117:Src/assert.c  ****         endOfMvt = 1;
 388              		.loc 1 117 0
 389 007c 0023     		movs	r3, #0
 390 007e 224A     		ldr	r2, .L32+4
 391 0080 1360     		str	r3, [r2]
 118:Src/assert.c  ****         *consigneDroit = 0;
 392              		.loc 1 118 0
 393 0082 0121     		movs	r1, #1
 394 0084 214A     		ldr	r2, .L32+8
 395 0086 1160     		str	r1, [r2]
 119:Src/assert.c  ****         *consigneGauche = 0;
 396              		.loc 1 119 0
 397 0088 CAF80030 		str	r3, [r10]
 120:Src/assert.c  ****     }
 398              		.loc 1 120 0
ARM GAS  /tmp/ccgp9pkP.s 			page 11


 399 008c C8F80030 		str	r3, [r8]
 400 0090 33E0     		b	.L23
 401              	.L27:
 402              	.LVL41:
 403              	.LBB2:
 130:Src/assert.c  **** 		errorSumDroite += errorDroite;
 404              		.loc 1 130 0
 405 0092 C4F1AA04 		rsb	r4, r4, #170
 406              	.LVL42:
 131:Src/assert.c  **** 		/*//circular buffer
 407              		.loc 1 131 0
 408 0096 1E4A     		ldr	r2, .L32+12
 409 0098 1368     		ldr	r3, [r2]
 410 009a 2344     		add	r3, r3, r4
 411 009c 1360     		str	r3, [r2]
 412              	.LVL43:
 142:Src/assert.c  **** 		oldErrorDroite = errorDroite;
 413              		.loc 1 142 0
 414 009e 04EB8409 		add	r9, r4, r4, lsl #2
 415 00a2 4FEA4909 		lsl	r9, r9, #1
 416 00a6 51EC180B 		fmrrd	r0, r1, d8
 417 00aa 0022     		movs	r2, #0
 418 00ac 194B     		ldr	r3, .L32+16
 419 00ae FFF7FEFF 		bl	__aeabi_dmul
 420              	.LVL44:
 421 00b2 0646     		mov	r6, r0
 422 00b4 0F46     		mov	r7, r1
 423 00b6 4846     		mov	r0, r9
 424 00b8 FFF7FEFF 		bl	__aeabi_i2d
 425              	.LVL45:
 426 00bc 3246     		mov	r2, r6
 427 00be 3B46     		mov	r3, r7
 428 00c0 FFF7FEFF 		bl	__aeabi_dadd
 429              	.LVL46:
 430 00c4 FFF7FEFF 		bl	__aeabi_d2iz
 431              	.LVL47:
 432 00c8 CAF80000 		str	r0, [r10]
 143:Src/assert.c  **** 		
 433              		.loc 1 143 0
 434 00cc 124B     		ldr	r3, .L32+20
 435 00ce 1C60     		str	r4, [r3]
 146:Src/assert.c  **** 		errorSumGauche += errorGauche;
 436              		.loc 1 146 0
 437 00d0 C5F1AA04 		rsb	r4, r5, #170
 438              	.LVL48:
 147:Src/assert.c  **** 		int errorVariationGauche = errorGauche - oldErrorGauche;
 439              		.loc 1 147 0
 440 00d4 114A     		ldr	r2, .L32+24
 441 00d6 1368     		ldr	r3, [r2]
 442 00d8 2344     		add	r3, r3, r4
 443 00da 1360     		str	r3, [r2]
 444              	.LVL49:
 149:Src/assert.c  **** 		oldErrorGauche = errorGauche;
 445              		.loc 1 149 0
 446 00dc 04EB8400 		add	r0, r4, r4, lsl #2
 447 00e0 4000     		lsls	r0, r0, #1
 448 00e2 FFF7FEFF 		bl	__aeabi_i2d
ARM GAS  /tmp/ccgp9pkP.s 			page 12


 449              	.LVL50:
 450 00e6 3246     		mov	r2, r6
 451 00e8 3B46     		mov	r3, r7
 452 00ea FFF7FEFF 		bl	__aeabi_dsub
 453              	.LVL51:
 454 00ee FFF7FEFF 		bl	__aeabi_d2iz
 455              	.LVL52:
 456 00f2 C8F80000 		str	r0, [r8]
 150:Src/assert.c  **** 	}
 457              		.loc 1 150 0
 458 00f6 0A4B     		ldr	r3, .L32+28
 459 00f8 1C60     		str	r4, [r3]
 460              	.LVL53:
 461              	.L23:
 462              	.LBE2:
 153:Src/assert.c  **** 
 463              		.loc 1 153 0
 464 00fa BDEC068B 		fldmfdd	sp!, {d8-d10}
 465              	.LCFI9:
 466              		.cfi_restore 84
 467              		.cfi_restore 85
 468              		.cfi_restore 82
 469              		.cfi_restore 83
 470              		.cfi_restore 80
 471              		.cfi_restore 81
 472              		.cfi_def_cfa_offset 32
 473              	.LVL54:
 474 00fe BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 475              	.LVL55:
 476              	.L33:
 477 0102 00BF     		.align	2
 478              	.L32:
 479 0104 00004940 		.word	1078525952
 480 0108 00000000 		.word	.LANCHOR1
 481 010c 00000000 		.word	.LANCHOR0
 482 0110 00000000 		.word	.LANCHOR2
 483 0114 00408F40 		.word	1083129856
 484 0118 00000000 		.word	.LANCHOR3
 485 011c 00000000 		.word	.LANCHOR4
 486 0120 00000000 		.word	.LANCHOR5
 487              		.cfi_endproc
 488              	.LFE126:
 490              		.section	.text.stateMachine,"ax",%progbits
 491              		.align	2
 492              		.global	stateMachine
 493              		.thumb
 494              		.thumb_func
 496              	stateMachine:
 497              	.LFB124:
  40:Src/assert.c  ****     static int state = 0;
 498              		.loc 1 40 0
 499              		.cfi_startproc
 500              		@ args = 64, pretend = 0, frame = 0
 501              		@ frame_needed = 0, uses_anonymous_args = 0
 502              	.LVL56:
 503 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 504              	.LCFI10:
ARM GAS  /tmp/ccgp9pkP.s 			page 13


 505              		.cfi_def_cfa_offset 28
 506              		.cfi_offset 4, -28
 507              		.cfi_offset 5, -24
 508              		.cfi_offset 6, -20
 509              		.cfi_offset 7, -16
 510              		.cfi_offset 8, -12
 511              		.cfi_offset 9, -8
 512              		.cfi_offset 14, -4
 513 0004 2DED068B 		fstmfdd	sp!, {d8, d9, d10}
 514              	.LCFI11:
 515              		.cfi_def_cfa_offset 52
 516              		.cfi_offset 80, -52
 517              		.cfi_offset 81, -48
 518              		.cfi_offset 82, -44
 519              		.cfi_offset 83, -40
 520              		.cfi_offset 84, -36
 521              		.cfi_offset 85, -32
 522 0008 91B0     		sub	sp, sp, #68
 523              	.LCFI12:
 524              		.cfi_def_cfa_offset 120
 525 000a 8146     		mov	r9, r0
 526 000c 8846     		mov	r8, r1
 527 000e B0EE40AA 		fcpys	s20, s0
 528 0012 F0EE60AA 		fcpys	s21, s1
 529 0016 B0EE419A 		fcpys	s18, s2
 530 001a F0EE619A 		fcpys	s19, s3
 531 001e B0EE428A 		fcpys	s16, s4
 532 0022 F0EE628A 		fcpys	s17, s5
 533 0026 1746     		mov	r7, r2
 534 0028 1E46     		mov	r6, r3
  43:Src/assert.c  ****     {
 535              		.loc 1 43 0
 536 002a 3D4B     		ldr	r3, .L42
 537              	.LVL57:
 538 002c 1B68     		ldr	r3, [r3]
 539 002e 012B     		cmp	r3, #1
 540 0030 0DD1     		bne	.L35
  45:Src/assert.c  ****         state += 1;
 541              		.loc 1 45 0
 542 0032 0022     		movs	r2, #0
 543              	.LVL58:
 544 0034 3A4B     		ldr	r3, .L42
 545 0036 1A60     		str	r2, [r3]
  46:Src/assert.c  ****         HAL_UART_Transmit(&huart2, "Fin de l'action\n", sizeof("Fin de l'action\n"), HAL_MAX_DELAY)
 546              		.loc 1 46 0
 547 0038 3A4A     		ldr	r2, .L42+4
 548 003a 1368     		ldr	r3, [r2]
 549 003c 0133     		adds	r3, r3, #1
 550 003e 1360     		str	r3, [r2]
  47:Src/assert.c  ****     }
 551              		.loc 1 47 0
 552 0040 1EA8     		add	r0, sp, #120
 553              	.LVL59:
 554 0042 3949     		ldr	r1, .L42+8
 555              	.LVL60:
 556 0044 1122     		movs	r2, #17
 557 0046 4FF0FF33 		mov	r3, #-1
ARM GAS  /tmp/ccgp9pkP.s 			page 14


 558 004a FFF7FEFF 		bl	HAL_UART_Transmit
 559              	.LVL61:
 560              	.L35:
  50:Src/assert.c  ****     {
 561              		.loc 1 50 0
 562 004e 354B     		ldr	r3, .L42+4
 563 0050 1B68     		ldr	r3, [r3]
 564 0052 364A     		ldr	r2, .L42+12
 565 0054 D25C     		ldrb	r2, [r2, r3]	@ zero_extendqisi2
 566 0056 452A     		cmp	r2, #69
 567 0058 54D0     		beq	.L37
 568 005a 4D2A     		cmp	r2, #77
 569 005c 02D0     		beq	.L38
 570 005e 412A     		cmp	r2, #65
 571 0060 58D1     		bne	.L34
 572 0062 27E0     		b	.L39
 573              	.L38:
  53:Src/assert.c  ****         //char buffer[50] = "";
 574              		.loc 1 53 0
 575 0064 DB00     		lsls	r3, r3, #3
 576 0066 324A     		ldr	r2, .L42+16
 577 0068 1A44     		add	r2, r2, r3
 578 006a 92ED003B 		fldd	d3, [r2]
 579 006e 314A     		ldr	r2, .L42+20
 580 0070 1344     		add	r3, r3, r2
 581 0072 93ED004B 		fldd	d4, [r3]
 582 0076 6C46     		mov	r4, sp
 583 0078 1EAD     		add	r5, sp, #120
 584 007a 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 585 007c 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 586 007e 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 587 0080 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 588 0082 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 589 0084 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 590 0086 95E80F00 		ldmia	r5, {r0, r1, r2, r3}
 591 008a 84E80F00 		stmia	r4, {r0, r1, r2, r3}
 592 008e 4846     		mov	r0, r9
 593 0090 4146     		mov	r1, r8
 594 0092 B0EE4A0A 		fcpys	s0, s20
 595 0096 F0EE6A0A 		fcpys	s1, s21
 596 009a B0EE491A 		fcpys	s2, s18
 597 009e F0EE691A 		fcpys	s3, s19
 598 00a2 B0EE482A 		fcpys	s4, s16
 599 00a6 F0EE682A 		fcpys	s5, s17
 600 00aa 3A46     		mov	r2, r7
 601 00ac 3346     		mov	r3, r6
 602 00ae FFF7FEFF 		bl	move
 603              	.LVL62:
  57:Src/assert.c  ****         
 604              		.loc 1 57 0
 605 00b2 2FE0     		b	.L34
 606              	.L39:
  60:Src/assert.c  **** 		break;
 607              		.loc 1 60 0
 608 00b4 DB00     		lsls	r3, r3, #3
 609 00b6 1E4A     		ldr	r2, .L42+16
 610 00b8 1A44     		add	r2, r2, r3
ARM GAS  /tmp/ccgp9pkP.s 			page 15


 611 00ba 92ED003B 		fldd	d3, [r2]
 612 00be 1D4A     		ldr	r2, .L42+20
 613 00c0 1344     		add	r3, r3, r2
 614 00c2 93ED004B 		fldd	d4, [r3]
 615 00c6 6C46     		mov	r4, sp
 616 00c8 1EAD     		add	r5, sp, #120
 617 00ca 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 618 00cc 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 619 00ce 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 620 00d0 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 621 00d2 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 622 00d4 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 623 00d6 95E80F00 		ldmia	r5, {r0, r1, r2, r3}
 624 00da 84E80F00 		stmia	r4, {r0, r1, r2, r3}
 625 00de 4846     		mov	r0, r9
 626 00e0 4146     		mov	r1, r8
 627 00e2 B0EE4A0A 		fcpys	s0, s20
 628 00e6 F0EE6A0A 		fcpys	s1, s21
 629 00ea B0EE491A 		fcpys	s2, s18
 630 00ee F0EE691A 		fcpys	s3, s19
 631 00f2 B0EE482A 		fcpys	s4, s16
 632 00f6 F0EE682A 		fcpys	s5, s17
 633 00fa 3A46     		mov	r2, r7
 634 00fc 3346     		mov	r3, r6
 635 00fe FFF7FEFF 		bl	turn
 636              	.LVL63:
  61:Src/assert.c  **** 
 637              		.loc 1 61 0
 638 0102 07E0     		b	.L34
 639              	.L37:
  64:Src/assert.c  ****         while(1){}
 640              		.loc 1 64 0
 641 0104 1EA8     		add	r0, sp, #120
 642 0106 0C49     		ldr	r1, .L42+24
 643 0108 0E22     		movs	r2, #14
 644 010a 4FF0FF33 		mov	r3, #-1
 645 010e FFF7FEFF 		bl	HAL_UART_Transmit
 646              	.LVL64:
 647              	.L40:
  65:Src/assert.c  ****         break;
 648              		.loc 1 65 0 discriminator 1
 649 0112 FEE7     		b	.L40
 650              	.L34:
  68:Src/assert.c  **** 
 651              		.loc 1 68 0
 652 0114 11B0     		add	sp, sp, #68
 653              	.LCFI13:
 654              		.cfi_def_cfa_offset 52
 655              		@ sp needed
 656 0116 BDEC068B 		fldmfdd	sp!, {d8-d10}
 657              	.LCFI14:
 658              		.cfi_restore 84
 659              		.cfi_restore 85
 660              		.cfi_restore 82
 661              		.cfi_restore 83
 662              		.cfi_restore 80
 663              		.cfi_restore 81
ARM GAS  /tmp/ccgp9pkP.s 			page 16


 664              		.cfi_def_cfa_offset 28
 665              	.LVL65:
 666 011a BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 667              	.LVL66:
 668              	.L43:
 669 011e 00BF     		.align	2
 670              	.L42:
 671 0120 00000000 		.word	.LANCHOR0
 672 0124 00000000 		.word	.LANCHOR6
 673 0128 00000000 		.word	.LC0
 674 012c 00000000 		.word	.LANCHOR7
 675 0130 00000000 		.word	.LANCHOR8
 676 0134 00000000 		.word	.LANCHOR9
 677 0138 14000000 		.word	.LC1
 678              		.cfi_endproc
 679              	.LFE124:
 681              		.global	endOfMvt
 682              		.global	val2
 683              		.global	val1
 684              		.global	consignes
 685              		.section	.bss.isMvtDone.7953,"aw",%nobits
 686              		.align	2
 687              		.set	.LANCHOR1,. + 0
 690              	isMvtDone.7953:
 691 0000 00000000 		.space	4
 692              		.section	.bss.errorSumGauche.7957,"aw",%nobits
 693              		.align	2
 694              		.set	.LANCHOR4,. + 0
 697              	errorSumGauche.7957:
 698 0000 00000000 		.space	4
 699              		.section	.data.val1,"aw",%progbits
 700              		.align	3
 701              		.set	.LANCHOR8,. + 0
 704              	val1:
 705 0000 00000000 		.word	0
 706 0004 00002440 		.word	1076101120
 707 0008 00000000 		.word	0
 708 000c 0000E03F 		.word	1071644672
 709 0010 00000000 		.word	0
 710 0014 00002440 		.word	1076101120
 711 0018 00000000 		.word	0
 712 001c 0000F0BF 		.word	-1074790400
 713 0020 00000000 		.word	0
 714 0024 00002440 		.word	1076101120
 715 0028 00000000 		.word	0
 716 002c 00000000 		.word	0
 717              		.section	.bss.val2,"aw",%nobits
 718              		.align	3
 719              		.set	.LANCHOR9,. + 0
 722              	val2:
 723 0000 00000000 		.space	48
 723      00000000 
 723      00000000 
 723      00000000 
 723      00000000 
 724              		.section	.bss.state.7923,"aw",%nobits
 725              		.align	2
ARM GAS  /tmp/ccgp9pkP.s 			page 17


 726              		.set	.LANCHOR6,. + 0
 729              	state.7923:
 730 0000 00000000 		.space	4
 731              		.section	.bss.oldErrorDroite.7954,"aw",%nobits
 732              		.align	2
 733              		.set	.LANCHOR3,. + 0
 736              	oldErrorDroite.7954:
 737 0000 00000000 		.space	4
 738              		.section	.rodata.str1.4,"aMS",%progbits,1
 739              		.align	2
 740              	.LC0:
 741 0000 46696E20 		.ascii	"Fin de l'action\012\000"
 741      6465206C 
 741      27616374 
 741      696F6E0A 
 741      00
 742 0011 000000   		.space	3
 743              	.LC1:
 744 0014 46696E20 		.ascii	"Fin de match\012\000"
 744      6465206D 
 744      61746368 
 744      0A00
 745              		.section	.bss.oldErrorGauche.7956,"aw",%nobits
 746              		.align	2
 747              		.set	.LANCHOR5,. + 0
 750              	oldErrorGauche.7956:
 751 0000 00000000 		.space	4
 752              		.section	.bss.endOfMvt,"aw",%nobits
 753              		.align	2
 754              		.set	.LANCHOR0,. + 0
 757              	endOfMvt:
 758 0000 00000000 		.space	4
 759              		.section	.bss.errorSumDroite.7955,"aw",%nobits
 760              		.align	2
 761              		.set	.LANCHOR2,. + 0
 764              	errorSumDroite.7955:
 765 0000 00000000 		.space	4
 766              		.section	.data.consignes,"aw",%progbits
 767              		.align	2
 768              		.set	.LANCHOR7,. + 0
 771              	consignes:
 772 0000 4D       		.byte	77
 773 0001 41       		.byte	65
 774 0002 4D       		.byte	77
 775 0003 41       		.byte	65
 776 0004 4D       		.byte	77
 777 0005 45       		.byte	69
 778              		.text
 779              	.Letext0:
 780              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 781              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 782              		.file 4 "Drivers/CMSIS/Device/ST/STM32F4xx/Include/stm32f401xe.h"
 783              		.file 5 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_def.h"
 784              		.file 6 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_dma.h"
 785              		.file 7 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_uart.h"
 786              		.file 8 "Drivers/CMSIS/Include/core_cm4.h"
 787              		.file 9 "/usr/include/newlib/math.h"
ARM GAS  /tmp/ccgp9pkP.s 			page 18


ARM GAS  /tmp/ccgp9pkP.s 			page 19


DEFINED SYMBOLS
                            *ABS*:0000000000000000 assert.c
     /tmp/ccgp9pkP.s:25     .text.updatePos:0000000000000000 $t
     /tmp/ccgp9pkP.s:30     .text.updatePos:0000000000000000 updatePos
     /tmp/ccgp9pkP.s:155    .text.updatePos:00000000000000d8 $d
     /tmp/ccgp9pkP.s:163    .text.absPerso:0000000000000000 $t
     /tmp/ccgp9pkP.s:168    .text.absPerso:0000000000000000 absPerso
     /tmp/ccgp9pkP.s:204    .text.turn:0000000000000000 $t
     /tmp/ccgp9pkP.s:209    .text.turn:0000000000000000 turn
     /tmp/ccgp9pkP.s:296    .text.turn:0000000000000078 $d
     /tmp/ccgp9pkP.s:305    .text.move:0000000000000000 $t
     /tmp/ccgp9pkP.s:310    .text.move:0000000000000000 move
     /tmp/ccgp9pkP.s:479    .text.move:0000000000000104 $d
     /tmp/ccgp9pkP.s:491    .text.stateMachine:0000000000000000 $t
     /tmp/ccgp9pkP.s:496    .text.stateMachine:0000000000000000 stateMachine
     /tmp/ccgp9pkP.s:671    .text.stateMachine:0000000000000120 $d
     /tmp/ccgp9pkP.s:757    .bss.endOfMvt:0000000000000000 endOfMvt
     /tmp/ccgp9pkP.s:722    .bss.val2:0000000000000000 val2
     /tmp/ccgp9pkP.s:704    .data.val1:0000000000000000 val1
     /tmp/ccgp9pkP.s:771    .data.consignes:0000000000000000 consignes
     /tmp/ccgp9pkP.s:686    .bss.isMvtDone.7953:0000000000000000 $d
     /tmp/ccgp9pkP.s:690    .bss.isMvtDone.7953:0000000000000000 isMvtDone.7953
     /tmp/ccgp9pkP.s:693    .bss.errorSumGauche.7957:0000000000000000 $d
     /tmp/ccgp9pkP.s:697    .bss.errorSumGauche.7957:0000000000000000 errorSumGauche.7957
     /tmp/ccgp9pkP.s:700    .data.val1:0000000000000000 $d
     /tmp/ccgp9pkP.s:718    .bss.val2:0000000000000000 $d
     /tmp/ccgp9pkP.s:725    .bss.state.7923:0000000000000000 $d
     /tmp/ccgp9pkP.s:729    .bss.state.7923:0000000000000000 state.7923
     /tmp/ccgp9pkP.s:732    .bss.oldErrorDroite.7954:0000000000000000 $d
     /tmp/ccgp9pkP.s:736    .bss.oldErrorDroite.7954:0000000000000000 oldErrorDroite.7954
     /tmp/ccgp9pkP.s:739    .rodata.str1.4:0000000000000000 $d
     /tmp/ccgp9pkP.s:746    .bss.oldErrorGauche.7956:0000000000000000 $d
     /tmp/ccgp9pkP.s:750    .bss.oldErrorGauche.7956:0000000000000000 oldErrorGauche.7956
     /tmp/ccgp9pkP.s:753    .bss.endOfMvt:0000000000000000 $d
     /tmp/ccgp9pkP.s:760    .bss.errorSumDroite.7955:0000000000000000 $d
     /tmp/ccgp9pkP.s:764    .bss.errorSumDroite.7955:0000000000000000 errorSumDroite.7955
     /tmp/ccgp9pkP.s:767    .data.consignes:0000000000000000 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
__aeabi_f2d
__aeabi_ddiv
__aeabi_dadd
__aeabi_dmul
cos
sin
__aeabi_dcmplt
__aeabi_dcmpgt
__aeabi_dsub
__aeabi_i2d
__aeabi_d2iz
HAL_UART_Transmit
